Ниже показано, как допустить **ровно** `"*.local"` и при этом оставить все ранние запреты (полная `"*"` и «слишком высокий» wildcard).

### 1 – что меняется в Rego

Добавляем **ещё одно** упрощённое правило `valid_host`, располагая его до основного, — OPA вернёт `true`, как только найдёт первое совпадение:

```rego
package k8stenantwildcardhost

###############################################################################
# 0) спец-исключение: разрешаем "*.local" без tenant-метки
###############################################################################
valid_host(host) {
  host == "*.local"
}

###############################################################################
# 1) общий случай: *.TENANT.<suffix>  (как раньше)
###############################################################################
valid_host(host) {
  suffix := input.parameters.domainSuffixes[_]
  safe   := replace(suffix, ".", "\\.")
  pattern := sprintf("^[*]\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?\\.%s$", [safe])
  re_match(pattern, host)
}

###############################################################################
# ❶ – полный wildcard "*"
###############################################################################
violation[{ "msg": msg }] {
  input.review.kind.kind == "Gateway"

  server := input.review.object.spec.servers[_]
  host   := server.hosts[_]

  host == "*"
  msg := sprintf(
    "Полный wildcard %q запрещён — он перехватывает весь входящий трафик.",
    [host])
}

###############################################################################
# ❷ – wildcard выше уровня TENANT
###############################################################################
violation[{ "msg": msg }] {
  input.review.kind.kind == "Gateway"

  server := input.review.object.spec.servers[_]
  host   := server.hosts[_]

  startswith(host, "*.")        # звёздочка есть…
  not valid_host(host)          # …но ни одно из разрешений не сработало

  msg := sprintf(
    "Wildcard host %q запрещён. Допустим только \"*.local\" или шаблон "
    "*.TENANT.<suffix>, где <suffix> входит в %v.",
    [host, input.parameters.domainSuffixes])
}
```

### 2 – почему это работает

* **Первое** правило `valid_host` срабатывает только на точную строку `"*.local"` — она пропускается без tenant-метки.
* Для остальных имён действует **старый** регэксп → по-прежнему нужна промежуточная метка.
* Проверка `host == "*"` осталась; одиночная звёздочка всё ещё запрещена.
* Блок `violation` теперь формируется лишь тогда, когда `valid_host(host)` **не вернул** `true`.

### 3 – как применить

```bash
# обновляем ConstraintTemplate
kubectl apply -f k8stenantwildcardhost-template.yaml
kubectl wait --for=condition=Ready constrainttemplate/k8stenantwildcardhost --timeout=60s
# Constraint пересоздавать не нужно — логика изменилась внутри шаблона
```

**Проверка:**

| hosts в Gateway                                  | Результат                                |
| ------------------------------------------------ | ---------------------------------------- |
| `["*.local"]`                                    | ✅ разрешено                              |
| `["*"]`                                          | ❌ отклонено («полный wildcard запрещён») |
| `["*.alice.asm-uk-01.uat.hc.intranet.corp.com"]` | ✅ разрешено                              |
| `["*.alice.hc.intranet.corp.com"]`               | ❌ отклонено                              |

Так вы получаете точное исключение для `*.local`, не ослабляя остальных ограничений.
